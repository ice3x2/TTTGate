# TTTGate 분석 보고서

## 1. 개요
*   **프로젝트:** TTTGate (Node.js 기반 TCP 터널링 애플리케이션)
*   **기술:** TypeScript, Node.js (백엔드), Svelte/Vite (관리자 UI)
*   **핵심 구조:** 서버-클라이언트 모델을 기반으로, 외부 요청을 내부 서비스로 전달하는 터널링을 수행합니다. 전체적으로 이벤트 기반의 비동기 방식으로 구현되어 있습니다.

## 2. 아키텍처 분석
*   **강점:**
    *   **책임 분리:** 서버와 클라이언트, 그리고 각 내부 모듈(외부 연결, 터널 제어)의 역할이 명확하게 분리되어 있습니다.
    *   **유연한 설정:** 설정 파일과 CLI 인자를 유연하게 조합하여 사용할 수 있습니다.
    *   **신뢰성:** 데몬 모드, 자동 재연결 등 안정적인 서비스를 위한 기능들이 구현되어 있습니다.
*   **개선 제안:**
    *   **상태 관리:** 현재 각 클래스 내부에서 상태(`_isOnline`, `_sessions` 등)를 개별적으로 관리하고 있습니다. 향후 기능이 복잡해질 것을 대비해 상태 관리 로직을 중앙에서 관리하는 패턴을 도입하는 것을 고려해볼 수 있습니다.

## 3. 코드 품질 분석
*   **강점:**
    *   TypeScript를 적극적으로 활용하여 타입 안정성을 확보했습니다.
    *   `async/await`를 일관되게 사용하여 비동기 코드를 깔끔하게 작성했습니다.
*   **개선 제안:**
    *   **리팩토링:** `ClientApp.ts`의 `_loadClientOption` 함수와 같이 여러 책임을 가진 긴 함수를 단일 책임 원칙(SRP)에 따라 작은 함수들로 분리할 것을 권장합니다.
    *   **CLI 처리 표준화:** `yargs`나 `commander.js` 같은 라이브러리를 도입하면, 직접 구현한 CLI 인자 파싱 로직을 더 단순하고 안정적으로 만들 수 있습니다.
    *   **테스트 부재:** `package.json`에 테스트 설정(`jest`)은 있으나 실제 테스트 코드가 없습니다. 핵심 터널링 로직에 대한 단위/통합 테스트를 추가하여 코드 안정성을 크게 향상시켜야 합니다.

## 4. 보안 분석
*   **강점:**
    *   TLS 암호화를 지원하여 통신 내용을 보호합니다.
    *   인증 키 및 `allowedClientNames`를 통해 허가된 클라이언트만 서버에 접속하도록 제한합니다.
*   **개선 제안:**
    *   **의존성 검사 자동화:** `npm audit`이나 `snyk` 같은 도구를 CI/CD 파이프라인에 통합하여, 사용 중인 외부 라이브러리의 보안 취약점을 정기적으로 자동 검사해야 합니다.
    *   **인증 강화:** 현재의 공유 키 방식에 더해, 상호 TLS 인증(mTLS) 같은 더 강력한 인증 메커니즘을 도입하여 보안을 한 단계 더 강화할 수 있습니다.

## 5. 성능 분석
*   **강점:**
    *   Node.js의 이벤트 기반 비동기 I/O 모델은 대량의 네트워크 요청을 효율적으로 처리하는 데 매우 유리합니다.
*   **개선 제안:**
    *   **백프레셔(Backpressure) 처리:** 한쪽의 데이터 처리 속도가 다른 쪽을 앞지를 경우, 메모리 사용량이 급증할 수 있습니다. `socket.write()`가 `false`를 반환할 때 `drain` 이벤트를 기다리는 등, 명시적인 백프레셔 처리를 추가하여 대용량 데이터 전송 시 메모리 안정성을 높여야 합니다.
    *   **부하 테스트:** 다수의 동시 터널과 대용량 데이터 전송 상황을 가정한 부하 테스트를 수행하여 시스템의 성능 한계와 병목 지점을 미리 파악할 필요가 있습니다.

## 최종 요약 및 권장 사항
이 프로젝트는 잘 설계된 아키텍처를 기반으로 안정적인 터널링 기능을 제공합니다. 다만 코드의 장기적인 안정성과 보안을 위해 다음 사항들을 우선적으로 개선할 것을 권장합니다.

*   **1순위 (안정성/보안):**
    *   핵심 로직에 대한 **테스트 코드 작성**
    *   자동화된 **의존성 보안 검사** 도입
*   **2순위 (품질/안정성):**
    *   네트워크 안정성을 위한 **백프레셔 처리** 구현
    *   CLI 인자 처리 로직 **라이브러리로 교체**
*   **3순위 (장기적 개선):**
    *   **부하 테스트**를 통한 성능 한계 측정
    *   더 강력한 **인증 방식** 도입 고려

---

## 심층 분석 (Detailed Analysis)

### 서버 모드 상세 분석 (Server Mode In-Depth Analysis)

#### 1. 초기화 및 실행 (Initialization & Execution)
*   **`app.ts`**: 애플리케이션의 최상위 진입점입니다. `process.argv`를 분석하여 실행 모드가 'server'일 경우 `ServerApp.start()`를 호출하여 서버를 시작합니다.
*   **`Sentinel.ts`**: `-daemon` 옵션을 처리하여 프로세스를 백그라운드에서 실행하고, 예기치 않은 종료 시 재시작하는 등의 프로세스 모니터링 및 관리를 담당합니다.
*   **`Environment.ts`**: 버전 정보, 빌드 번호, 설정 및 로그 파일이 저장될 디렉토리 경로 등 애플리케이션 전반에서 사용되는 환경 정보를 정의합니다.
*   **`util/logger/*`**: `winston` 라이브러리를 기반으로 한 로깅 시스템입니다. 콘솔 출력과 파일 기록을 동시에 지원하며, 서버의 모든 주요 활동과 오류는 `logs/` 디렉토리에 저장됩니다.

#### 2. 핵심 서버 애플리케이션 (`server/ServerApp.ts`)
서버 모드의 모든 구성 요소를 총괄하는 컨트롤 타워 역할을 합니다.
1.  `ServerOptionStore`를 통해 `config.yaml`에서 설정을 로드합니다.
2.  `CertificationStore`를 통해 TLS 통신에 필요한 인증서를 준비합니다.
3.  `AdminServer` (관리자 웹서버 및 API)를 실행합니다.
4.  `TTTServer` (핵심 터널링 서버)를 실행합니다.

#### 3. 터널링 엔진 (`server/TTTServer.ts`)
`TTTServer`는 터널링 기능의 핵심이며, 두 개의 주요 풀(Pool)을 조합하여 동작합니다.
*   **`server/TunnelServer.ts`**: 클라이언트(`TTTClient`)로부터의 제어 연결(Control Connection)을 수신하고 관리합니다. 클라이언트 인증, 터널 세션 생성/종료 등 모든 제어 관련 로직을 담당합니다.
*   **`server/ExternalPortServerPool.ts`**: `config.yaml`에 정의된 각 터널의 외부 포트(예: 8080)를 열고, 최종 사용자(End-user)로부터의 데이터 연결을 수신합니다.

*   **서버 데이터 흐름:**
    1.  최종 사용자가 서버의 특정 외부 포트(예: 8080)로 접속하면 `ExternalPortServerPool`이 연결을 수락합니다.
    2.  `TTTServer`는 이 연결을 위한 새 세션 ID를 생성하고, `TunnelServer`를 통해 해당 터널을 사용하는 `TTTClient`에게 "목적지(예: `localhost:3000`)로 연결하라"는 명령을 내립니다.
    3.  명령을 받은 `TTTClient`는 실제 목적지로 연결을 수립합니다.
    4.  연결이 성공하면, 최종 사용자와 실제 목적지 간의 데이터는 `ExternalPortServerPool` ↔ `TTTServer` ↔ `TunnelServer` ↔ `TTTClient` 경로를 통해 양방향으로 스트리밍됩니다.

#### 4. 관리자 서버 (`server/admin/AdminServer.ts`)
`Express.js`를 기반으로 한 내장 웹 서버입니다.
*   **UI 제공**: `admin` 디렉토리의 Svelte 빌드 결과물(HTML, JS, CSS)을 정적 파일로 제공하여 관리자 웹페이지를 서비스합니다.
*   **REST API**: 서버 상태 조회, 터널 옵션 변경, 인증서 관리 등 서버를 제어하기 위한 REST API 엔드포인트를 제공합니다.
*   **`server/admin/SessionStore.ts`**: 관리자 페이지의 로그인 상태를 유지하기 위한 세션 저장소입니다.

---

### 클라이언트 모드 상세 분석 (Client Mode In-Depth Analysis)

#### 1. 초기화 및 실행 (`client/ClientApp.ts`)
*   `app.ts`에서 실행 모드가 'client'로 감지되면 `ClientApp.start()`가 호출됩니다.
*   `ClientApp`은 `client.yaml` 설정 파일과 CLI 인자를 종합하여 최종 클라이언트 설정을 확정합니다.
*   설정이 완료되면 `TTTClient` 인스턴스를 생성하고 `start()` 메소드를 호출합니다.

#### 2. 핵심 클라이언트 (`client/TTTClient.ts`)
클라이언트 측의 모든 동작을 총괄하며, 서버와 대칭적인 구조로 두 개의 풀(Pool)을 관리합니다.
*   **`client/TunnelClient.ts`**: `TTTServer`로의 제어 연결을 수립하고 유지합니다. 서버로부터 오는 명령(세션 생성/종료 등)을 이곳에서 수신하며, 연결이 끊겼을 때 자동으로 재연결하는 로직을 포함하고 있습니다.
*   **`client/EndPointClientPool.ts`**: `TTTServer`로부터 "특정 목적지로 연결하라"는 명령을 받았을 때, 실제 목적지(예: 로컬에서 실행 중인 웹서버 `localhost:3000`)로의 데이터 연결을 생성하고 관리합니다.

*   **클라이언트 데이터 흐름:**
    1.  `TunnelClient`가 `TTTServer`와의 제어 연결을 유지합니다.
    2.  `TTTServer`가 새 터널 세션을 만들어야 할 때, 제어 연결을 통해 `TunnelClient`에게 목적지 정보와 함께 연결 명령을 보냅니다.
    3.  `TTTClient`는 이 명령을 받아 `EndPointClientPool`에 목적지로의 연결을 지시합니다.
    4.  `EndPointClientPool`이 목적지에 연결되면, 해당 연결에서 발생하는 데이터는 `TunnelClient`를 통해 `TTTServer`로 전송되어 최종 사용자에게 전달됩니다.